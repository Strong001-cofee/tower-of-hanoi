<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tower of Hanoi</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        color: white;
        user-select: none;
        touch-action: manipulation;
        overflow-x: hidden;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 800px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 10px;
      }

      .stats {
        font-size: 18px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .difficulty-selector {
        display: flex;
        gap: 5px;
        margin-right: 10px;
      }

      .difficulty-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 10px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .difficulty-btn.active {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.8);
        transform: scale(1.05);
      }

      .difficulty-btn:hover,
      .difficulty-btn:active {
        background: rgba(255, 255, 255, 0.25);
        transform: scale(1.02);
      }

      .reset-btn {
        background: #ff6b6b;
        border: none;
        color: white;
        padding: 12px 20px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .reset-btn:hover,
      .reset-btn:active {
        background: #ff5252;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .game-container {
        width: 100%;
        max-width: 800px;
        height: 400px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        padding: 40px 20px;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
      }

      .rods-container {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        height: 100%;
        position: relative;
        gap: 10px;
      }

      .rod {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        width: 120px;
        min-height: 280px;
        -webkit-tap-highlight-color: transparent;
      }

      .rod.selected {
        transform: scale(1.05);
      }

      .rod.invalid-target {
        animation: shake 0.5s ease-in-out;
      }

      .rod.tap-feedback {
        transform: scale(0.98);
        filter: brightness(1.2);
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-8px);
        }
        75% {
          transform: translateX(8px);
        }
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .rod-pole {
        width: 8px;
        height: 250px;
        background: linear-gradient(to bottom, #8b4513, #654321);
        border-radius: 4px;
        position: relative;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .rod-base {
        width: 100px;
        height: 20px;
        background: linear-gradient(to bottom, #8b4513, #654321);
        border-radius: 10px;
        margin-top: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .rod-label {
        margin-top: 10px;
        font-size: 18px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.8);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .disk {
        height: 25px;
        border-radius: 15px;
        margin-bottom: 2px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.3);
        position: absolute;
        z-index: 10;
        -webkit-tap-highlight-color: transparent;
        will-change: transform;
      }

      .disk::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: inherit;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.3) 0%,
          rgba(255, 255, 255, 0.1) 50%,
          rgba(0, 0, 0, 0.1) 100%
        );
        pointer-events: none;
      }

      .disk.selected {
        transform: translateX(-50%) translateY(-15px) scale(1.1);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
        z-index: 100;
        animation: pulse 1.5s infinite ease-in-out;
      }

      .disk.tap-feedback {
        transform: translateX(-50%) translateY(-5px) scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .disk:active {
        transform: translateX(-50%) translateY(-3px) scale(1.02);
      }

      .win-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        display: none;
        z-index: 1000;
        backdrop-filter: blur(10px);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        max-width: 90vw;
      }

      .win-stats {
        margin: 15px 0;
        font-size: 18px;
        color: #ffd700;
        line-height: 1.4;
      }

      .instructions {
        margin-top: 20px;
        text-align: center;
        font-size: 16px;
        color: rgba(255, 255, 255, 0.8);
        max-width: 600px;
        line-height: 1.5;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }

      /* Enhanced Mobile Styles */
      @media (max-width: 768px) {
        body {
          padding: 15px 10px;
        }

        .header {
          flex-direction: column;
          gap: 15px;
          margin-bottom: 15px;
        }

        .controls {
          justify-content: center;
        }

        .difficulty-selector {
          margin-right: 0;
          margin-bottom: 10px;
        }

        .difficulty-btn {
          padding: 12px 16px;
          font-size: 13px;
          min-height: 48px;
          border-radius: 10px;
        }

        .reset-btn {
          padding: 14px 24px;
          font-size: 16px;
          min-height: 48px;
          border-radius: 12px;
        }

        .game-container {
          height: 380px;
          padding: 30px 15px;
          border-radius: 15px;
        }

        .rods-container {
          gap: 5px;
        }

        .rod {
          width: 100px;
          min-height: 300px;
        }

        .rod-pole {
          height: 220px;
          width: 7px;
        }

        .rod-base {
          width: 85px;
          height: 18px;
        }

        .rod-label {
          font-size: 16px;
          margin-top: 8px;
        }

        .disk {
          height: 22px;
          border-radius: 12px;
          margin-bottom: 1px;
          border-width: 1.5px;
        }

        .disk.selected {
          transform: translateX(-50%) translateY(-12px) scale(1.08);
        }

        .disk.tap-feedback {
          transform: translateX(-50%) translateY(-3px) scale(1.03);
        }

        .disk:active {
          transform: translateX(-50%) translateY(-2px) scale(1.01);
        }

        .stats {
          font-size: 16px;
        }

        .instructions {
          font-size: 14px;
          margin-top: 15px;
          padding: 0 10px;
        }

        .win-message {
          font-size: 20px;
          padding: 25px 20px;
          border-radius: 15px;
        }

        .win-stats {
          font-size: 16px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 10px 5px;
        }

        .game-container {
          height: 320px;
          padding: 20px 10px;
          border-radius: 12px;
        }

        .rods-container {
          gap: 2px;
        }

        .rod {
          width: 85px;
          min-height: 260px;
        }

        .rod-pole {
          height: 180px;
          width: 6px;
        }

        .rod-base {
          width: 70px;
          height: 15px;
        }

        .rod-label {
          font-size: 14px;
          margin-top: 6px;
        }

        .disk {
          height: 20px;
          border-radius: 10px;
          border-width: 1px;
        }

        .disk.selected {
          transform: translateX(-50%) translateY(-10px) scale(1.06);
        }

        .disk.tap-feedback {
          transform: translateX(-50%) translateY(-2px) scale(1.02);
        }

        .disk:active {
          transform: translateX(-50%) translateY(-1px) scale(1.01);
        }

        .difficulty-btn {
          padding: 10px 12px;
          font-size: 12px;
          min-height: 44px;
        }

        .reset-btn {
          padding: 12px 20px;
          font-size: 14px;
          min-height: 44px;
        }

        .stats {
          font-size: 14px;
        }

        .instructions {
          font-size: 13px;
          margin-top: 12px;
        }

        .win-message {
          font-size: 18px;
          padding: 20px 15px;
        }

        .win-stats {
          font-size: 14px;
        }
      }

      @media (max-width: 360px) {
        .game-container {
          height: 300px;
          padding: 15px 8px;
        }

        .rod {
          width: 75px;
          min-height: 240px;
        }

        .rod-pole {
          height: 160px;
          width: 5px;
        }

        .rod-base {
          width: 60px;
          height: 12px;
        }

        .disk {
          height: 18px;
          border-radius: 9px;
        }

        .disk.selected {
          transform: translateX(-50%) translateY(-8px) scale(1.04);
        }

        .difficulty-btn {
          padding: 8px 10px;
          font-size: 11px;
          min-height: 40px;
        }

        .reset-btn {
          padding: 10px 16px;
          font-size: 13px;
          min-height: 40px;
        }
      }

      /* Touch feedback animations */
      @keyframes tapFeedback {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
        }
        100% {
          transform: scale(1);
        }
      }

      .touch-feedback {
        animation: tapFeedback 0.2s ease-out;
      }

      /* High DPI displays */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        .disk {
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .disk.selected {
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="stats">
        <div id="moveCounter">Moves: 0</div>
      </div>
      <div class="controls">
        <div class="difficulty-selector">
          <button class="difficulty-btn" data-disks="3">Easy (3)</button>
          <button class="difficulty-btn active" data-disks="4">
            Medium (4)
          </button>
          <button class="difficulty-btn" data-disks="5">Hard (5)</button>
        </div>
        <button class="reset-btn" id="resetBtn">New Game</button>
      </div>
      <div class="stats">
        <div id="timer">Time: 00:00</div>
      </div>
    </div>

    <div class="game-container">
      <div class="rods-container" id="rodsContainer">
        <div class="rod" data-rod="0">
          <div class="rod-pole"></div>
          <div class="rod-base"></div>
          <div class="rod-label">A</div>
        </div>
        <div class="rod" data-rod="1">
          <div class="rod-pole"></div>
          <div class="rod-base"></div>
          <div class="rod-label">B</div>
        </div>
        <div class="rod" data-rod="2">
          <div class="rod-pole"></div>
          <div class="rod-base"></div>
          <div class="rod-label">C</div>
        </div>
      </div>

      <div class="win-message" id="winMessage">
        <div>🎉 Congratulations! 🎉</div>
        <div class="win-stats" id="winStats"></div>
        <div>Click "New Game" to play again!</div>
      </div>
    </div>

    <div class="instructions">
      <strong>How to Play:</strong> Tap a rod to select the top disk, then tap
      another rod to move it. You can only place smaller disks on larger ones.
      Move all disks from Rod A to Rod C!
    </div>

    <script>
      // Game state container
      const gameState = {
        rods: [[], [], []],
        moves: 0,
        startTime: null,
        gameActive: false,
        selectedRod: null,
        diskCount: 4,
        timer: null,
        isMobile:
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ),
      };

      // Disk colors for different sizes
      const diskColors = [
        "linear-gradient(45deg, #ff6b6b, #ee5a52)",
        "linear-gradient(45deg, #4ecdc4, #44a08d)",
        "linear-gradient(45deg, #45b7d1, #3498db)",
        "linear-gradient(45deg, #f9ca24, #f0932b)",
        "linear-gradient(45deg, #6c5ce7, #a29bfe)",
        "linear-gradient(45deg, #fd79a8, #e84393)",
      ];

      // Enhanced touch feedback
      function addTouchFeedback(element, className = "tap-feedback") {
        element.classList.add(className);
        setTimeout(() => element.classList.remove(className), 200);
      }

      // Initialize game with specified number of disks
      function initializeGame(diskCount = 4) {
        gameState.diskCount = diskCount;
        gameState.rods = [[], [], []];
        gameState.moves = 0;
        gameState.startTime = null;
        gameState.gameActive = false;
        gameState.selectedRod = null;

        // Create disks on first rod (largest to smallest)
        for (let i = diskCount; i >= 1; i--) {
          gameState.rods[0].push(i);
        }

        updateDisplay();
        clearInterval(gameState.timer);
        document.getElementById("timer").textContent = "Time: 00:00";
        document.getElementById("winMessage").style.display = "none";
      }

      // Calculate disk width based on size and screen width
      function getDiskWidth(size, maxSize) {
        const screenWidth = window.innerWidth;
        let minWidth, maxWidth;

        if (screenWidth <= 360) {
          minWidth = 25;
          maxWidth = 65;
        } else if (screenWidth <= 480) {
          minWidth = 30;
          maxWidth = 75;
        } else if (screenWidth <= 768) {
          minWidth = 35;
          maxWidth = 85;
        } else {
          minWidth = 40;
          maxWidth = 100;
        }

        return minWidth + (maxWidth - minWidth) * (size / maxSize);
      }

      // Get base position for disk placement
      function getBasePosition() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= 360) {
          return 30;
        } else if (screenWidth <= 480) {
          return 35;
        } else if (screenWidth <= 768) {
          return 40;
        } else {
          return 45;
        }
      }

      // Get disk spacing
      function getDiskSpacing() {
        const screenWidth = window.innerWidth;
        if (screenWidth <= 360) {
          return 17;
        } else if (screenWidth <= 480) {
          return 19;
        } else if (screenWidth <= 768) {
          return 21;
        } else {
          return 25;
        }
      }

      // Render all disks on rods with proper mobile positioning
      function renderDisks() {
        const rods = document.querySelectorAll(".rod");

        rods.forEach((rodElement, rodIndex) => {
          // Remove existing disks
          const existingDisks = rodElement.querySelectorAll(".disk");
          existingDisks.forEach((disk) => disk.remove());

          // Add disks from bottom to top
          const rodDisks = gameState.rods[rodIndex];
          const diskHeight =
            window.innerWidth <= 360
              ? 18
              : window.innerWidth <= 480
              ? 20
              : window.innerWidth <= 768
              ? 22
              : 25;
          const diskSpacing = getDiskSpacing();
          const basePosition = getBasePosition();

          rodDisks.forEach((diskSize, diskIndex) => {
            const disk = document.createElement("div");
            disk.className = "disk";
            disk.style.width =
              getDiskWidth(diskSize, gameState.diskCount) + "px";
            disk.style.height = diskHeight + "px";
            disk.style.background =
              diskColors[(diskSize - 1) % diskColors.length];
            disk.style.position = "absolute";
            disk.style.bottom = basePosition + diskIndex * diskSpacing + "px";
            disk.style.left = "50%";
            disk.style.transform = "translateX(-50%)";
            disk.dataset.size = diskSize;

            // Enhanced touch events for mobile
            if (gameState.isMobile) {
              disk.addEventListener(
                "touchstart",
                (e) => {
                  e.preventDefault();
                  addTouchFeedback(disk);
                },
                { passive: false }
              );

              disk.addEventListener(
                "touchend",
                (e) => {
                  e.preventDefault();
                  e.stopPropagation();

                  // Only handle if this is the top disk
                  const topDiskIndex = gameState.rods[rodIndex].length - 1;
                  if (diskIndex === topDiskIndex) {
                    handleRodClick(rodIndex);
                  }
                },
                { passive: false }
              );
            }

            rodElement.appendChild(disk);
          });
        });
      }

      // Update move counter and timer display
      function updateDisplay() {
        document.getElementById(
          "moveCounter"
        ).textContent = `Moves: ${gameState.moves}`;
        renderDisks();
      }

      // Start the game timer
      function startTimer() {
        if (!gameState.startTime) {
          gameState.startTime = Date.now();
          gameState.timer = setInterval(() => {
            const elapsed = Math.floor(
              (Date.now() - gameState.startTime) / 1000
            );
            const minutes = Math.floor(elapsed / 60)
              .toString()
              .padStart(2, "0");
            const seconds = (elapsed % 60).toString().padStart(2, "0");
            document.getElementById(
              "timer"
            ).textContent = `Time: ${minutes}:${seconds}`;
          }, 1000);
        }
      }

      // Check if move is valid
      function isValidMove(fromRod, toRod) {
        if (gameState.rods[fromRod].length === 0) return false;
        if (gameState.rods[toRod].length === 0) return true;

        const fromDisk =
          gameState.rods[fromRod][gameState.rods[fromRod].length - 1];
        const toDisk = gameState.rods[toRod][gameState.rods[toRod].length - 1];

        return fromDisk < toDisk;
      }

      // Execute a move with enhanced feedback
      function makeMove(fromRod, toRod) {
        if (!isValidMove(fromRod, toRod)) {
          // Enhanced invalid move feedback
          const rodElement = document.querySelector(`[data-rod="${toRod}"]`);
          rodElement.classList.add("invalid-target");

          // Add haptic feedback on mobile
          if (gameState.isMobile && navigator.vibrate) {
            navigator.vibrate(100);
          }

          setTimeout(() => rodElement.classList.remove("invalid-target"), 500);
          return false;
        }

        const disk = gameState.rods[fromRod].pop();
        gameState.rods[toRod].push(disk);
        gameState.moves++;

        // Add success haptic feedback
        if (gameState.isMobile && navigator.vibrate) {
          navigator.vibrate(50);
        }

        startTimer();
        updateDisplay();

        // Check for win condition
        if (gameState.rods[2].length === gameState.diskCount) {
          setTimeout(showWinMessage, 300);
        }

        return true;
      }

      // Display win message
      function showWinMessage() {
        clearInterval(gameState.timer);
        const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        const timeText =
          minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

        const minMoves = Math.pow(2, gameState.diskCount) - 1;
        const efficiency = Math.round((minMoves / gameState.moves) * 100);

        // Celebration haptic feedback
        if (gameState.isMobile && navigator.vibrate) {
          navigator.vibrate([100, 50, 100, 50, 200]);
        }

        document.getElementById("winStats").innerHTML = `
          Completed in ${gameState.moves} moves (minimum: ${minMoves})<br>
          Time: ${timeText} | Efficiency: ${efficiency}%
        `;
        document.getElementById("winMessage").style.display = "block";
      }

      // Handle rod selection and moves with enhanced touch support
      function handleRodClick(rodIndex) {
        if (gameState.selectedRod === null) {
          // Select rod if it has disks
          if (gameState.rods[rodIndex].length > 0) {
            gameState.selectedRod = rodIndex;
            const rodElement = document.querySelector(
              `[data-rod="${rodIndex}"]`
            );
            rodElement.classList.add("selected");

            addTouchFeedback(rodElement);

            // Highlight the top disk
            const topDisk = document.querySelector(
              `[data-rod="${rodIndex}"] .disk:last-child`
            );
            if (topDisk) topDisk.classList.add("selected");
          }
        } else {
          // Clear visual feedback first
          const rodElement = document.querySelector(`[data-rod="${rodIndex}"]`);
          addTouchFeedback(rodElement);

          // Attempt to move disk
          if (rodIndex === gameState.selectedRod) {
            // Deselect if clicking same rod
            clearSelection();
          } else {
            // Try to make the move
            makeMove(gameState.selectedRod, rodIndex);
            clearSelection();
          }
        }
      }

      // Clear current selection
      function clearSelection() {
        if (gameState.selectedRod !== null) {
          document
            .querySelector(`[data-rod="${gameState.selectedRod}"]`)
            .classList.remove("selected");
          const selectedDisk = document.querySelector(".disk.selected");
          if (selectedDisk) selectedDisk.classList.remove("selected");
          gameState.selectedRod = null;
        }
      }

      // Set up event listeners with enhanced mobile support
      function setupEventListeners() {
        // Rod click/touch handlers
        document.querySelectorAll(".rod").forEach((rod, index) => {
          // Mouse events for desktop
          rod.addEventListener("click", (e) => {
            e.stopPropagation();
            if (!gameState.isMobile) {
              handleRodClick(index);
            }
          });

          // Enhanced touch events for mobile
          if (gameState.isMobile) {
            let touchStartTime;
            let touchMoved = false;

            rod.addEventListener(
              "touchstart",
              (e) => {
                touchStartTime = Date.now();
                touchMoved = false;
                addTouchFeedback(rod);
              },
              { passive: true }
            );

            rod.addEventListener(
              "touchmove",
              (e) => {
                touchMoved = true;
              },
              { passive: true }
            );

            rod.addEventListener(
              "touchend",
              (e) => {
                e.preventDefault();
                e.stopPropagation();

                const touchDuration = Date.now() - touchStartTime;

                // Only register as tap if touch was brief and didn't move
                if (!touchMoved && touchDuration < 300) {
                  handleRodClick(index);
                }
              },
              { passive: false }
            );
          }
        });

        // Enhanced button interactions
        document.getElementById("resetBtn").addEventListener("click", (e) => {
          addTouchFeedback(e.target, "touch-feedback");
          initializeGame(gameState.diskCount);
          clearSelection();
        });

        // Difficulty selector with enhanced touch feedback
        document.querySelectorAll(".difficulty-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            addTouchFeedback(e.target, "touch-feedback");

            // Update active button
            document
              .querySelectorAll(".difficulty-btn")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");

            // Start new game with selected difficulty
            const diskCount = parseInt(btn.dataset.disks);
            initializeGame(diskCount);
            clearSelection();
          });
        });

        // Clear selection when clicking outside
        document.addEventListener("click", (e) => {
          if (!e.target.closest(".rod") && !e.target.closest(".disk")) {
            clearSelection();
          }
        });

        // Enhanced touch event for clearing selection on mobile
        if (gameState.isMobile) {
          document.addEventListener("touchend", (e) => {
            if (!e.target.closest(".rod") && !e.target.closest(".disk")) {
              clearSelection();
            }
          });
        }

        // Keyboard support for accessibility
        document.addEventListener("keydown", (e) => {
          if (e.key >= "1" && e.key <= "3") {
            const rodIndex = parseInt(e.key) - 1;
            handleRodClick(rodIndex);
          } else if (e.key === "Escape") {
            clearSelection();
          } else if (e.key === "r" || e.key === "R") {
            initializeGame(gameState.diskCount);
            clearSelection();
          }
        });

        // Handle window resize for responsive design
        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            updateDisplay();
          }, 100);
        });

        // Prevent context menu on long press for mobile
        if (gameState.isMobile) {
          document.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          // Prevent zoom on double tap
          document.addEventListener("touchend", (e) => {
            const now = new Date().getTime();
            const timeSince = now - gameState.lastTouchEnd;

            if (timeSince < 300 && timeSince > 0) {
              e.preventDefault();
            }

            gameState.lastTouchEnd = now;
          });
        }
      }

      // Optimize performance for mobile devices
      function optimizeForMobile() {
        if (gameState.isMobile) {
          // Add touch-action CSS to prevent default behaviors
          document.body.style.touchAction = "manipulation";

          // Disable text selection on mobile
          document.body.style.webkitUserSelect = "none";
          document.body.style.userSelect = "none";

          // Add viewport meta tag if not present
          if (!document.querySelector('meta[name="viewport"]')) {
            const viewport = document.createElement("meta");
            viewport.name = "viewport";
            viewport.content =
              "width=device-width, initial-scale=1.0, user-scalable=no";
            document.head.appendChild(viewport);
          }
        }
      }

      // Auto-solve feature (for demonstration/hints)
      function getOptimalSolution(
        n,
        source = 0,
        destination = 2,
        auxiliary = 1
      ) {
        if (n === 1) {
          return [[source, destination]];
        }

        const moves = [];
        moves.push(
          ...getOptimalSolution(n - 1, source, auxiliary, destination)
        );
        moves.push([source, destination]);
        moves.push(
          ...getOptimalSolution(n - 1, auxiliary, destination, source)
        );

        return moves;
      }

      // Hint system
      function getNextHint() {
        const solution = getOptimalSolution(gameState.diskCount);
        const currentMoves = [];

        // This would need to track actual game state to provide real hints
        // For now, just show the first move as an example
        if (gameState.moves === 0) {
          return solution[0];
        }

        return null;
      }

      // Initialize everything when page loads
      document.addEventListener("DOMContentLoaded", () => {
        optimizeForMobile();
        setupEventListeners();
        initializeGame(4); // Start with medium difficulty

        // Add game state property for touch timing
        gameState.lastTouchEnd = 0;

        // Focus management for accessibility
        document.body.setAttribute("tabindex", "0");

        // Prevent scrolling when playing on mobile
        if (gameState.isMobile) {
          document.body.addEventListener(
            "touchmove",
            (e) => {
              if (e.target.closest(".game-container")) {
                e.preventDefault();
              }
            },
            { passive: false }
          );
        }

        console.log("Tower of Hanoi initialized successfully!");
      });

      // Export game functions for potential external use
      window.HanoiGame = {
        reset: () => initializeGame(gameState.diskCount),
        setDifficulty: (disks) => initializeGame(disks),
        getState: () => ({ ...gameState }),
        getHint: getNextHint,
      };
    </script>
  </body>
</html>
